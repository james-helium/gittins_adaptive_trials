#this script combines the previously written ER and GI simulations of 2-armed trials
#and simulate the two designs in different trial conditions to produce visualisations

##########################
#FILES, LIBS, and PREVIOUS FUNCTIONS
#from previous scripts attempts
##########################

#import the table copied from Gittins et al 2011 (Table 8.13 trimmed)
GI_table <- readxl::read_xlsx('GI Exponential.xlsx')
#make a new empty data frame to fill data for each n
GI_interpolated <- data.frame(2:900, NA, NA, NA, NA)
colnames(GI_interpolated) <- c('n', '0.8', '0.9', '0.95', '0.99')
#if the n is recorded in the original table, copy it directly
GI_interpolated[GI_interpolated$n %in% GI_table$n, -1] <- GI_table[,-1]
#interpolate:
for(row in 1:nrow(GI_interpolated)){
  #for readability we have a short-hand n
  n <- GI_interpolated$n[row]
  if(!n %in% GI_table$n){ # if this n needs interpolating
    #we retrieve the available n before it and after it 
    n_priv <- max(GI_table$n[GI_table$n < n])
    n_next <- min(GI_table$n[GI_table$n > n])
    #get the step assuming even intervals
    step <- (GI_table[GI_table$n == n_next,-1] - GI_table[GI_table$n == n_priv,-1]) / (n_next - n_priv)
    #interpolate at the position of n
    GI_interpolated[GI_interpolated$n == n,-1] <- GI_table[GI_table$n == n_priv,-1] + step * (n - n_priv)
  }
  #print for progress
  print(paste(row, 'out of', nrow(GI_interpolated), 'interpolated'))
}

#outcome function, output a random reward following exp. with given parameters
simulate_exponential_outcome <- function(mean){
  outcome <- rexp(1, rate = 1/mean)
  outcome
}

#trials function, output a trial outcome dataframe containing statistics of each simulated trials
simulate_trials_ER <- function(N, mu_0, mu_1, R){
  #create a dataframe to store each trial simulation's statistics
  trial.outcomes <- data.frame(Prop.Superior = rep(NA, R), Test.Stat = rep(NA, R), Estimate = rep(NA, R), Total.Outcome = rep(NA, R))
  #in a for loop, simulate each trials and populate the frame row by row
  for(i in 1:R){
    #simulate one trial that sequentially allocate patients to the two arms at random with fixed equal probability
    patient.outcome <- data.frame(Arm = rep(NA, N), Outcome = rep(NA, N))
    for(t in 1:N){ #take in patients sequentially
      patient.outcome$Arm[t] <- ifelse(runif(1) >= 0.5, 1, 0) #allocation to arms at random - this should be the thing that changes when we run other trial designs
      patient.outcome$Outcome[t] <- ifelse(patient.outcome$Arm[t] == 0, 
                                           simulate_exponential_outcome(mu_0), 
                                           simulate_exponential_outcome(mu_1)) #simulate outcomes based on arms
    }
    #extract trial statistics from this outcome dataframe
    trial.outcomes$Prop.Superior[i] <- nrow(patient.outcome[patient.outcome$Arm == 1,]) / N
    #test statistics here is the p-value generated by a F distribution F(2n_1, 2n_2)
    trial.outcomes$Test.Stat[i] <- pf(mean(patient.outcome$Outcome[patient.outcome$Arm == 0])/mean(patient.outcome$Outcome[patient.outcome$Arm == 1]),
                                      df1 = 2*nrow(patient.outcome[patient.outcome$Arm == 0,]), df2 = 2*nrow(patient.outcome[patient.outcome$Arm == 1,]))
    trial.outcomes$Estimate[i] <- mean(patient.outcome$Outcome[patient.outcome$Arm == 1]) - mean(patient.outcome$Outcome[patient.outcome$Arm == 0])
    trial.outcomes$Total.Outcome[i] <- sum(patient.outcome$Outcome)
    #print for progress
    print(paste(i, 'out of', R, 'trials simulated'))
  }
  trial.outcomes #output
}

#a function for the GI allocation rule, 
#with constraint that ensures at least 1/k patient get allocated to each arm
#k should be < N to make sure that at least some patients are in the control, otherwise index gives treatment to everyone
simulate_trials_GI_constraint <- function(N, mu_0, mu_1, R, implicit_prior_n = 2, k = 5){
  #create a dataframe to store each trial simulation's statistics
  trial.outcomes <- data.frame(Prop.Superior = rep(NA, R), Test.Stat = rep(NA, R), Estimate = rep(NA, R), Total.Outcome = rep(NA, R))
  #set gittin index parameters
  discount_factor <- '0.99' #pre-set discount factor, can change later
  #in a for loop, simulate each trials and populate the frame row by row
  for(i in 1:R){
    
    #simulate one trial that sequentially allocate patients to the two arms at random with fixed equal probability
    patient.outcome <- data.frame(Arm = rep(NA, N), Outcome = rep(NA, N))
    #set initial index values of each arm; this is updated during the trial and decides on the allocation of the next patient
    GIs <- c(mu_0 * GI_interpolated[[discount_factor]][GI_interpolated$n == implicit_prior_n],
             mu_1 * GI_interpolated[[discount_factor]][GI_interpolated$n == implicit_prior_n])
    
    for(t in 1:N){ #take in patients sequentially
      
      #first, calculate the ratio of existing obs in each arms
      arm_0_ratio <- nrow(patient.outcome[!is.na(patient.outcome$Arm) & patient.outcome$Arm == 0,]) / 
        nrow(patient.outcome[!is.na(patient.outcome$Outcome),])
      arm_1_ratio <- 1 - arm_0_ratio
      
      #patient allocation following GI rules; ensuring at least 1/k of patients are in each arm; tie-break at random
      patient.outcome$Arm[t] <- 
        ifelse(nrow(patient.outcome[!is.na(patient.outcome$Outcome),]) == 0, #if there are no obs yet
               ifelse(GIs[1] != GIs[2], which.max(GIs) - 1, ifelse(runif(1) >= 0.5, 1, 0)), #assign by prior GI, tiebreak at random
               #otherwise, if there are observations,
               ifelse(arm_0_ratio < 1/k | arm_1_ratio < 1/k, #and if less than 1/k of existing obs are in each arm
                      which.min(c(arm_0_ratio,arm_1_ratio))-1, #assign to the lower one to get it up to 1/k
                      #otherwise, assign by prior GI, tiebreak at random
                      ifelse(GIs[1] != GIs[2], which.max(GIs) - 1, ifelse(runif(1) >= 0.5, 1, 0))))
      
      #simulate outcomes based on arms
      patient.outcome$Outcome[t] <- ifelse(patient.outcome$Arm[t] == 0, 
                                           simulate_exponential_outcome(mu_0), 
                                           simulate_exponential_outcome(mu_1)) 
      #update the GIs based on outcomes
      posterior_obs <- patient.outcome$Outcome[patient.outcome$Arm == patient.outcome$Arm[t] & !is.na(patient.outcome$Outcome)] #list of all obs in this arm so far
      GIs[patient.outcome$Arm[t] + 1] <- 
        (mu_0 * implicit_prior_n + sum(posterior_obs)) / (implicit_prior_n + length(posterior_obs)) * #posterior mean
        GI_interpolated[[discount_factor]][GI_interpolated$n == implicit_prior_n + length(posterior_obs)] #table value of v(âˆ‘,n) where lambda = 1
    }
    
    #extract trial statistics from this outcome dataframe
    trial.outcomes$Prop.Superior[i] <- nrow(patient.outcome[patient.outcome$Arm == which.max(c(mu_0,mu_1))-1,]) / N
    #test statistics here is the p-value generated by a F distribution F(2n_1, 2n_2)
    trial.outcomes$Test.Stat[i] <- pf(mean(patient.outcome$Outcome[patient.outcome$Arm == 0])/mean(patient.outcome$Outcome[patient.outcome$Arm == 1]),
                                      df1 = 2*nrow(patient.outcome[patient.outcome$Arm == 0,]), df2 = 2*nrow(patient.outcome[patient.outcome$Arm == 1,]))
    trial.outcomes$Estimate[i] <- mean(patient.outcome$Outcome[patient.outcome$Arm == 1])-mean(patient.outcome$Outcome[patient.outcome$Arm == 0])
    trial.outcomes$Total.Outcome[i] <- sum(patient.outcome$Outcome)
    #print for progress
    print(paste(i, 'out of', R, 'trials simulated'))
  }
  trial.outcomes #output
}


##########################
#SIMULATE & COMPARE
#in different trial conditions
##########################

#mimicking figure 3 in Mavrogonatou et al, 2022, see power curve in different effect sizes

#a function that outputs a data frame of x = mu_1 and y = power, accuracy, prop superior; for ER trials
simulate_mu_range_ER <- function(N, mu_0, mu_1_lower, mu_1_upper, mu_1_step, R){
  #create a data frame to store outcome
  output <- data.frame(mu_1 = seq(mu_1_lower, mu_1_upper, by = mu_1_step), 
                       Alpha = NA, Power = NA, H1.Estimate.SD = NA, H1.Prop.Superior = NA, H1.ETO.Change.Percent = NA)
  #go through each row to simulate
  for(row in 1:nrow(output)){
    mu_1 <- output$mu_1[row]
    cutoff <- 0.05
    #simulate by GI
    null.true <- simulate_trials_ER(N, mu_0, mu_0, R)
    alte.true <- simulate_trials_ER(N, mu_0, mu_1, R)
    #extract trial properties
    output$Alpha[row] <- ifelse(mu_1>mu_0, #split in cases for one-tailed tests
                                nrow(null.true[null.true$Test.Stat < cutoff,]) / nrow(null.true),
                                nrow(null.true[null.true$Test.Stat > 1-cutoff,]) / nrow(null.true))
    output$Power[row] <- ifelse(mu_1>mu_0,
                                1 - nrow(alte.true[alte.true$Test.Stat > cutoff,]) / nrow(alte.true),
                                1 - nrow(alte.true[alte.true$Test.Stat < 1-cutoff,]) / nrow(alte.true))
    output$H1.Estimate.SD[row] <- sd(alte.true$Estimate)
    output$H1.Prop.Superior[row] <- mean(alte.true$Prop.Superior)
    output$H1.ETO.Change.Percent[row] <- mean((alte.true$Total.Outcome - (mu_0*N/2+mu_1*N/2))/(mu_0*N/2+mu_1*N/2)*100)
  }
  output #output
}

#a function that outputs a data frame of x = mu_1 and y = power, accuracy, prop superior; for GI design with variable constrains
simulate_mu_range_GI_constraint <- function(N, mu_0, mu_1_lower, mu_1_upper, mu_1_step, R, implicit_prior_n, k){
  #create a data frame to store outcome
  output <- data.frame(mu_1 = seq(mu_1_lower, mu_1_upper, by = mu_1_step), 
                       Alpha = NA, Power = NA, H1.Estimate.SD = NA, H1.Prop.Superior = NA, H1.ETO.Change.Percent = NA)  
  #go through each row to simulate
  for(row in 1:nrow(output)){
    mu_1 <- output$mu_1[row]
    cutoff <- 0.05
    #simulate by GI
    null.true <- simulate_trials_GI_constraint(N, mu_0, mu_0, R, implicit_prior_n, k)
    alte.true <- simulate_trials_GI_constraint(N, mu_0, mu_1, R, implicit_prior_n, k)
    #extract trial properties
    output$Alpha[row] <- ifelse(mu_1>mu_0, #split in cases for one-tailed tests
                                nrow(null.true[null.true$Test.Stat < cutoff,]) / nrow(null.true),
                                nrow(null.true[null.true$Test.Stat > 1-cutoff,]) / nrow(null.true))
    output$Power[row] <- ifelse(mu_1>mu_0,
                                1 - nrow(alte.true[alte.true$Test.Stat > cutoff,]) / nrow(alte.true),
                                1 - nrow(alte.true[alte.true$Test.Stat < 1-cutoff,]) / nrow(alte.true))
    output$H1.Estimate.SD[row] <- sd(alte.true$Estimate)
    output$H1.Prop.Superior[row] <- mean(alte.true$Prop.Superior)
    output$H1.ETO.Change.Percent[row] <- mean((alte.true$Total.Outcome - (mu_0*N/2+mu_1*N/2))/(mu_0*N/2+mu_1*N/2)*100)
  }
  output #output
}

#set arbiturary mu_0 = 0.5, vary mu_1_lower = 0.1 and mu_1_upper = 0.9, mu_1_step = 0.01, implicit_prior_n = 2, N = 100, R = 500
#get trial property outcomes
mu_range_outcome_ER <- simulate_mu_range_ER(N = 100, mu_0 = 0.5, mu_1_lower = 0.1, mu_1_upper = 0.9, mu_1_step = 0.2, R = 100)
mu_range_outcome_GI_const_5 <- simulate_mu_range_GI_constraint(N = 100, mu_0 = 0.5, mu_1_lower = 0.1, mu_1_upper = 0.9, mu_1_step = 0.2,
                                                               R = 100, implicit_prior_n = 2, k = 5)
mu_range_outcome_GI_const_9 <- simulate_mu_range_GI_constraint(N = 100, mu_0 = 0.5, mu_1_lower = 0.1, mu_1_upper = 0.9, mu_1_step = 0.2,
                                                               R = 100, implicit_prior_n = 2, k = 9)
#for near-optimal case we only constrain for k = N / 2
mu_range_outcome_GI_near_op <- simulate_mu_range_GI_constraint(N = 100, mu_0 = 0.5, mu_1_lower = 0.1, mu_1_upper = 0.9, mu_1_step = 0.2,
                                                               R = 100, implicit_prior_n = 2, k = 100 / 2)

#save because it takes AGES to simulate
write.csv(mu_range_outcome_ER, 'EXP_mu_range_outcome_ER.csv')
write.csv(mu_range_outcome_GI_const_5, 'EXP_mu_range_outcome_GI_const_5.csv')
write.csv(mu_range_outcome_GI_const_9, 'EXP_mu_range_outcome_GI_const_9.csv')
write.csv(mu_range_outcome_GI_near_op, 'EXP_mu_range_outcome_GI_near_op.csv')

##########################
#VISUALISE COMPARISON
#and save to .pdf format
##########################

#get library and files
library(ggplot2)
library(gridExtra)
mu_range_outcome_ER <- read.csv('EXP_mu_range_outcome_ER.csv')[,-1]
mu_range_outcome_GI_const_5 <- read.csv('EXP_mu_range_outcome_GI_const_5.csv')[,-1]
mu_range_outcome_GI_const_9 <- read.csv('EXP_mu_range_outcome_GI_const_9.csv')[,-1]
mu_range_outcome_GI_near_op <- read.csv('EXP_mu_range_outcome_GI_near_op.csv')[,-1]

#first we combine the trial property outcome
mu_range_outcome_combined <- data.frame(rbind(mu_range_outcome_ER, mu_range_outcome_GI_const_5, 
                                              mu_range_outcome_GI_const_9, mu_range_outcome_GI_near_op),
                                        Design = c(rep('ER', nrow(mu_range_outcome_ER)), 
                                                   rep('GI-const-5', nrow(mu_range_outcome_GI_const_5)), 
                                                   rep('GI-const-9', nrow(mu_range_outcome_GI_const_9)),
                                                   rep('GI-near_op', nrow(mu_range_outcome_GI_near_op))))

#start plotting!
Power_Curve <- ggplot(data = mu_range_outcome_combined) +
  geom_point(aes(x = mu_1, y = Power, color = Design)) + 
  scale_color_manual(values = c('black', '#a65852', '#2c7c94', '#a4d49c')) +
  xlab(expression(paste('\U00B5'[1], ' (\U00B5'[0], ' = 0.50)'))) + ylab('') + 
  labs(title = 'Power') +
  theme(plot.title = element_text(hjust = 0.5), legend.position = 'none')

ETO_Curve <- ggplot(data = mu_range_outcome_combined) +
  geom_point(aes(x = mu_1, y = H1.ETO.Change.Percent, color = Design)) + 
  scale_color_manual(values = c('black', '#a65852', '#2c7c94', '#a4d49c')) +
  xlab(expression(paste('\U00B5'[1], ' (\U00B5'[0], ' = 0.50)'))) + ylab('') + 
  labs(title = '% Increase in ETO') +
  theme(plot.title = element_text(hjust = 0.5), legend.position = 'none')

Accuracy_Curve <- ggplot(data = mu_range_outcome_combined) +
  geom_point(aes(x = mu_1, y = H1.Estimate.SD, color = Design)) + 
  scale_color_manual(values = c('black', '#a65852', '#2c7c94', '#a4d49c')) +
  xlab(expression(paste('\U00B5'[1], ' (\U00B5'[0], ' = 0.50)'))) + ylab('') + 
  labs(title = expression(paste('\U03C3'['Estimate'], ' | H'[1]))) +
  theme(plot.title = element_text(hjust = 0.5), legend.position = 'none')

Prop_Sup_Curve <- ggplot(data = mu_range_outcome_combined) +
  geom_point(aes(x = mu_1, y = H1.Prop.Superior, color = Design)) + 
  scale_color_manual(values = c('black', '#a65852', '#2c7c94', '#a4d49c')) +
  xlab(expression(paste('\U00B5'[1], ' (\U00B5'[0], ' = 0.50)'))) + ylab('') + 
  labs(title = expression(paste('\U03C1'['superior'], ' | H'[1]))) +
  theme(plot.title = element_text(hjust = 0.5), legend.position = 'none')

#combine all 4 into one plot
quartz(type = 'pdf', file = 'Trial Properties Comparison (Exponential GI v. ER).pdf', width = 9, height = 9)
grid.arrange(Power_Curve, Accuracy_Curve, Prop_Sup_Curve, ETO_Curve, nrow = 2)
dev.off()

